```bash
──(komugi㉿komugi)-[~/Desktop]
└─$ gdb -q moving_immediate_data
Reading symbols from moving_immediate_data...
(No debugging symbols found in moving_immediate_data)
(gdb) b _start
Breakpoint 1 at 0x8049000
(gdb) r
Starting program: /home/komugi/Desktop/moving_immediate_data 

Breakpoint 1, 0x08049000 in _start ()
(gdb) disas
Dump of assembler code for function _start:
=> 0x08049000 <+0>:     nop
End of assembler dump.
(gdb) si
0x08049001 in mov_immediate_data_to_register ()
(gdb) disas
Dump of assembler code for function mov_immediate_data_to_register:
=> 0x08049001 <+0>:     mov    $0x64,%eax
   0x08049006 <+5>:     movb   $0x50,0x804a000
End of assembler dump.
(gdb) si
0x08049006 in mov_immediate_data_to_register ()
(gdb) i r
eax            0x64                100
ecx            0x0                 0
edx            0x0                 0
ebx            0x0                 0
esp            0xffffcfc0          0xffffcfc0
ebp            0x0                 0x0
esi            0x0                 0
edi            0x0                 0
eip            0x8049006           0x8049006 <mov_immediate_data_to_register+5>
eflags         0x202               [ IF ]
cs             0x23                35
ss             0x2b                43
ds             0x2b                43
es             0x2b                43
fs             0x0                 0
gs             0x0                 0

gdb) si
0x0804900d in exit ()
(gdb) disas
Dump of assembler code for function exit:
=> 0x0804900d <+0>:     mov    $0x1,%eax
   0x08049012 <+5>:     mov    $0x0,%ebx
   0x08049017 <+10>:    int    $0x80
End of assembler dump.
(gdb) print /x buffer
'buffer' has unknown type; cast it to its declared type
(gdb) print /x buffer 
'buffer' has unknown type; cast it to its declared type
(gdb) print /x
The history is empty.
(gdb) x/xb
Argument required (starting display address).
(gdb) 

```
## We can see EAX has the value of 0x64 or 100 decimal. Lets HACK that value now by setting EAX to say something like 0x66 by typing set $eax = 0x66
---

### **Step-by-Step Analysis**

1. **Loading the Program in GDB:**
   ```bash
   gdb -q moving_immediate_data
   ```
   - You opened the binary in GDB, but there are no debugging symbols (`(No debugging symbols found...)`). This is because the program was likely compiled without the `-g` flag, which includes debugging information.

2. **Setting a Breakpoint at `_start`:**
   ```bash
   b _start
   ```
   - This sets a breakpoint at the program's entry point `_start`.

3. **Starting Execution:**
   ```bash
   r
   ```
   - The program starts, and execution stops at the `_start` label due to the breakpoint.

4. **Disassembling `_start`:**
   ```bash
   disas
   ```
   - The disassembler reveals a single instruction at `_start`:
     ```
     0x08049000 <+0>: nop
     ```
     - The `nop` instruction does nothing and is often used for alignment or as a placeholder.

5. **Single-Stepping (`si`):**
   ```bash
   si
   ```
   - Single-stepping advances execution to the next instruction, entering the `mov_immediate_data_to_register` label.

6. **Disassembling `mov_immediate_data_to_register`:**
   ```bash
   disas
   ```
   - The disassembler shows:
     ```
     0x08049001 <+0>: mov $0x64,%eax
     0x08049006 <+5>: movb $0x50,0x804a000
     ```
     - **`mov $0x64, %eax`:** Moves the value `0x64` (100 in decimal) into the `EAX` register.
     - **`movb $0x50, 0x804a000`:** Moves the byte value `0x50` into memory at address `0x804a000`.

7. **Inspecting Registers:**
   ```bash
   i r
   ```
   - Register `EAX` now holds `0x64` (decimal `100`), confirming the first instruction executed correctly.

---

### **What Happened?**
- The program executed the first `mov` instruction (`mov eax, 100`), successfully moving the immediate value `100` into the `EAX` register.
- Execution is currently at `movb $0x50, 0x804a000`, where it will store the immediate value `0x50` (80 in decimal) into the memory location `0x804a000`.

---

### **Key Observations**
1. **Address of `buffer`:**
   - The `.bss` section is uninitialized, and the memory address for `buffer` is assigned dynamically during linking. Here, `buffer` was resolved to `0x804a000`.
   - This matches the second instruction: `movb $0x50, 0x804a000`.

2. **Registers State:**
   - The `eax` register now holds the expected value (`100` in decimal), confirming that the first `mov` instruction executed as intended.

3. **EFLAGS Register:**
   - The `eflags` value of `0x202` indicates the **interrupt flag (IF)** is set, meaning interrupts are enabled. No other noteworthy flags are affected.

---

### **What to Do Next?**
- Step through the remaining instructions using `si` to verify the memory operation (`movb $0x50, 0x804a000`).
- Inspect memory at `0x804a000` after executing the `movb` instruction:
  ```bash
  x/1xb 0x804a000
  ```
  This will display the single byte at the memory address to confirm that `0x50` was written successfully.

---

### **Debugging Tips**
1. **Enable Debug Symbols:**
   Recompile your program with `-g` to include debugging symbols. This makes debugging easier by showing symbolic names for memory locations and labels.
   ```bash
   nasm -f elf32 -g -F dwarf moving_immediate_data.asm -o moving_immediate_data.o
   ld -m elf_i386 moving_immediate_data.o -o moving_immediate_data
   ```

2. **Verify the `.bss` Section:**
   Use tools like `objdump` or `readelf` to inspect the `.bss` section and confirm that `buffer` was allocated at the expected address.

3. **Disassemble the Entire Program:**
   Use `objdump -d` to disassemble the entire binary:
   ```bash
   objdump -d moving_immediate_data
   ```

---

### **Correct Way to Inspect Memory in GDB**

1. **Verify Memory Address of `buffer`:**
   Since `buffer` resides in the `.bss` section, its address is assigned dynamically. The `movb $0x50, 0x804a000` instruction suggests its address is `0x804a000`. You can directly inspect this address.

   ```bash
   x/1xb 0x804a000
   ```
   - `x`: Examine memory.
   - `/1x`: Display 1 value in hexadecimal format.
   - `b`: Treat it as a byte.

2. **Check Memory Content After `movb`:**
   If the instruction `movb $0x50, 0x804a000` has executed, the memory at `0x804a000` should now contain `0x50`. Use:
   ```bash
   x/1xb 0x804a000
   ```
   Expected output:
   ```
   0x804a000: 0x50
   ```

3. **Inspect `buffer` Symbol:**
   If GDB can't resolve `buffer` as a symbol, ensure the binary has debugging symbols by compiling with the `-g` flag during assembly:
   ```bash
   nasm -f elf32 -g -F dwarf moving_immediate_data.asm -o moving_immediate_data.o
   ld -m elf_i386 moving_immediate_data.o -o moving_immediate_data
   ```

4. **Print Symbolic Address of `buffer`:**
   Once debug symbols are enabled, you can display the address of `buffer`:
   ```bash
   print &buffer
   ```

5. **Explicit Memory Examination Using Symbol:**
   After confirming `buffer`'s address, examine its content directly:
   ```bash
   x/1xb &buffer
   ```

---

### **Addressing Common Issues**

1. **`buffer` has an unknown type:**
   This occurs because the binary lacks debugging symbols. Recompile the program with `-g` as shown above to include symbol information.

2. **`x/xb` requires an argument:**
   The `x` command needs a starting memory address. If `buffer` is unresolved, use its hardcoded address (`0x804a000` in this case).

3. **Check for Compiler Warnings:**
   If you're still unable to inspect memory, confirm that `buffer` was properly allocated in the `.bss` section. Use:
   ```bash
   objdump -t moving_immediate_data | grep buffer
   ```
   This will list `buffer`'s symbol and its resolved address.

---

**BAM! There we go! You can see the ULTIMATE power of assembly here! We just hacked the value from 0x64 to 0x66 or 100 to 102 decimal. This is a trivial example however you can clearly see when you learn to master these concepts you develop a greater power over the computer. With each program that we create, we will have a very simple lesson like this where we will hijack at least one portion of the code so we can not only see how the program is created and debugged but how we can manipulate it to whatever we want.**

### **Quick Debugging Script**
Here’s a series of commands to run in GDB for your current scenario:

```bash
b _start                    # Set breakpoint at _start
r                           # Run program
si                          # Step into mov_immediate_data_to_register
x/1xb 0x804a000             # Check memory at buffer's address
print &buffer               # Check buffer's symbolic address (if debug symbols exist)
```

---

### **Additional Debugging Tools**
1. **`readelf`:**
   Use `readelf -s moving_immediate_data` to inspect symbols and verify `buffer` is in `.bss`.

2. **`objdump`:**
   Use `objdump -d moving_immediate_data` to verify the disassembly and confirm that instructions match expectations.

These steps should help you confidently inspect `buffer` and verify the behavior of your assembly program.
