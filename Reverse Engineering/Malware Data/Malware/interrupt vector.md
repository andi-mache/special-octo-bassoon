### **Interrupt Vector in Assembly and System Programming**

The **interrupt vector** is a critical data structure in computing, typically implemented as a **table of pointers** or addresses. Each entry in this table corresponds to an **interrupt service routine (ISR)**, which is the code executed when a specific interrupt is triggered.

---

### **Interrupt Vector Table (IVT)**
- The **Interrupt Vector Table (IVT)** resides in a fixed memory location (platform-dependent).
- Each **interrupt type** has a predefined **index** or **vector number** in the table.
- The entry at that index contains the **address** of the ISR to be executed for the corresponding interrupt.

---

### **Structure of the IVT**
1. **Interrupt Vector Number (IVN):**
   - A unique identifier for each interrupt type.
2. **Interrupt Vector Entry:**
   - Points to the ISR.
   - On x86 systems, the IVT is typically located at address `0x0000` in real mode.
3. **Table Size:**
   - For 16-bit systems: Each entry is 4 bytes (2 bytes for segment, 2 bytes for offset).
   - For 32-bit systems: Each entry is 4 bytes (direct address).
   - For 64-bit systems: Each entry is 8 bytes.

---

### **How It Works**
1. When an interrupt occurs:
   - The processor calculates the vector's memory address by multiplying the interrupt vector number by the size of each entry (e.g., 4 bytes on x86 real mode).
   - It fetches the ISR's address from the table.
2. The processor saves the current state (e.g., flags, program counter, stack pointer).
3. It transfers control to the ISR.

---

### **Example (x86 Real Mode)**
- Location: IVT starts at memory address `0x0000`.
- Each entry: 4 bytes (2-byte segment, 2-byte offset).

#### **Interrupt Vector Example: INT 0x21**
- **Interrupt 0x21 (DOS services):**
  - Vector number: `0x21`
  - Address in IVT: `0x21 * 4 = 0x0084`

At `0x0084`:
1. 2 bytes → Offset of ISR.
2. 2 bytes → Segment of ISR.

#### **Assembly Code Example:**
```assembly
; Trigger interrupt 0x21 (DOS interrupt)
mov ah, 0x09        ; Function: Print String
mov dx, msg         ; Load address of string
int 0x21            ; Call interrupt

msg db 'Hello, Interrupt!$', 0
```

---

### **In Protected and Long Modes**
- The IVT concept extends but changes:
  1. **Protected Mode:**
     - Uses the **Interrupt Descriptor Table (IDT)** instead of IVT.
     - Each entry in IDT contains detailed information about the ISR.
  2. **Long Mode (x86-64):**
     - IDT also used, with 64-bit addresses.

---

### **Real-World Applications**
1. **Hardware Interrupts:** Handling I/O devices like keyboards, disks, and timers.
2. **Software Interrupts:** System calls or software-generated interrupts.
3. **Error Handling:** Divide-by-zero, invalid memory access, etc.

---

### **Advanced Concepts**
1. **Chaining ISRs:**
   - Multiple handlers can process one interrupt by calling the next ISR in the chain.
2. **Customizing IVT:**
   - Replace vector entries to redirect interrupts for custom handlers.

#### **Custom Handler Example:**
```assembly
cli                     ; Disable interrupts
mov ax, 0x0000          ; Segment of IVT
mov ds, ax              ; Load segment
mov word [0x0020], handler_offset  ; Replace offset of ISR
mov word [0x0022], handler_segment ; Replace segment of ISR
sti                     ; Re-enable interrupts

handler:
    ; Custom interrupt service routine code
    iret                ; Return from interrupt
```

---

### **Summary**
- The **Interrupt Vector** allows the CPU to locate and invoke the appropriate ISR for hardware or software interrupts.
- Understanding IVT/IDT is essential for low-level programming, debugging, and OS development.
