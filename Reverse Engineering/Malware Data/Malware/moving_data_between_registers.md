### **Code**

```asm
.section .data

.section .text
     .globl _start

_start:
     nop

     movl $22, %edx

     mov_data_between_registers:
         movl %edx, %eax  ; Move the value in EDX to EAX

exit:
     movl $1, %eax        ; syscall: exit
     movl $0, %ebx        ; exit code 0
     int $0x80            ; Call Linux kernel to exit
```

---


### **Explanation**

1. **`movl $22, %edx`:**
   - Loads the immediate value `22` into the `EDX` register.
   - The `l` suffix indicates this is a 32-bit operation.

2. **`movl %edx, %eax`:**
   - Moves the value from `EDX` to `EAX`, demonstrating register-to-register data movement.

3. **Exit Sequence:**
   - The `movl $1, %eax` sets up the `exit` system call (syscall number 1).
   - The `movl $0, %ebx` sets the exit status code to `0`.
   - The `int $0x80` invokes the Linux kernel interrupt to perform the system call.

---

### **Assembly Workflow**
To assemble, link, and run the program, follow these steps:

1. **Assemble:**
   ```bash
   nasm -f elf32 moving_data_between_registers.asm -o moving_data_between_registers.o
   ```

2. **Link:**
   ```bash
   ld -m elf_i386 moving_data_between_registers.o -o moving_data_between_registers
   ```

3. **Run:**
   ```bash
   ./moving_data_between_registers
   ```

---

### **Debugging with GDB**
If you want to debug and observe register contents, use GDB:

1. **Start GDB:**
   ```bash
   gdb -q moving_data_between_registers
   ```

2. **Set Breakpoints:**
   ```bash
   b mov_data_between_registers
   ```

3. **Run and Step Through:**
   ```bash
   r         # Run the program
   si        # Step through instructions
   ```

4. **Inspect Registers:**
   - After `movl $22, %edx`:
     ```bash
     i r edx
     ```
   - After `movl %edx, %eax`:
     ```bash
     i r eax
     ```

---
